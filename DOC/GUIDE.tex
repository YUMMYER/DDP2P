\documentclass{book}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{url}
\sloppy

%package style
\newcommand{\pkg}[1]{{\tt #1}}
\newcommand{\cls}[1]{{\tt\bf #1}}
\newcommand{\mth}[1]{{\tt #1}}
\newcommand{\mmb}[1]{{\tt #1}}

\title{DirectDemocracyP2P Architecture}

\author{Marius C. Silaghi, Khalid Alhamed, Osamah Dhanoon, Hang Dong,\\
 Song Qin, Rahul Vishen, Ryan Knowles, Yi Yang, Yog Lok Seo \\
... and hopefully you!}

\begin{document}
\maketitle
\chapter{Introduction}
\section{This document}
The latest version of this document is on {\tt \url{dev/MSilaghi/Doc/GUIDE.pdf}} in my SVN, or on the {\tt \url{https://github.com/ddp2p/DDP2P/tree/master/DOC/GUIDE.pdf}} (from now on this site is simply referred to as the {\tt github}).

\section{Release History}

The technical details and intentions of this project were first lined out in 2004 in the FIT technical report {\tt CS-2004-07}, that had also been  submitted in 2003 as an NSF funding request.
The funding was not grated, and after repeated requests to different governmental agencies (including a 2005 EU proposal with Markus Zanker from Austria and 10 EU institutions), 
in 2007 we started to develop the system as a volunteer work.
A first version of the system was developed as a web-application prototype (\url{http://debatedecide.fit.edu}). It was not P2P and its intentions was a proof of concept,
and potential demo for further funding requests. By 2009 it was nevertheless pretty complete and is still used to manage some classes at FIT. Its weaknesses are:
\begin{itemize}
\item
difficulties with the java applets plugins frequently not well supported by browsers (but needed to create and handle certificates).
\item
the system administrator has too much power as he can apply censorship and delete items.
\end{itemize}

In 2010 we started the P2P implementation of the system. First we still thought of a P2P prototype, in python. After a few months developing an interface with python,
we felt that it was less easy to build and maintain then an actual full system in Java.

The actual implementation of the open-source P2P Java program started in spring 2011 with the ASN1 packages and STUN-like NAT piercing mechanism.  The GUI development
started in summer 2011, with the tree view for constituents and neighborhoods (which helped revise the final structure of the corresponding objects. Song also started working
that summer on the Census panel. The swing GUI centered on developing autonomous widgets for various functions. Their assembly into an ergonomic GUI was left for
later (and not yet tackled by 2014). Currently widgets are just chained in a pretty long tab.... (apologize to those that do not like it, as you are welcome to change it to an ergonomic GUI).
The year 2012 was spent designing and implementing the various objects, integrating an ad-hoc network module (with Osamah Dhanoonn's master thesis), and integrating an automatic update mechanism
(with the PhD work of Khalid Alhamed).

The first public release of the system was in summer 2013, at the {\em Open Peer-Reviewed Workshop on Decentralized Coordination} that we organized at Florid Tech in April 7. There we presented the articles detailing the technical and scientific contributions of the first version. A demo was made at the P2P 2013 conference. The version 1 is pretty stable but slow, since the only synchronization
point of the various modules is the database on the disk. The database access is slow, which slows down the whole system. This is why in September 2013 we started working on a new version.
The version 1 was left untouched except for a few very minor fixes (versions 0.9.49 to 0.9.55), some proving more bothering then worth. The version is available on github in the {\tt src} folder.

While the second version (which uses a cache of objects as point of synchronization) is pretty finalized, there are still a couple of bugs (see the Bugs section), and was not yet released as an installation package until now (Oct 2014). You can download the code from the {\tt src\_version2} folder and compile it yourself.

\chapter{Development}
\section{Generating New Releases}

To generate a new release (or a new tester recommendation) first one
needs a secret key that I typically store in a file
``Trusted64.sk''. This file consists of two lines: the first line
contains the secret key and the second line contains the public key.
One can generate such a file from the software with the method
\cls{DD}.\mth{createTrustedSKFile()} in package \pkg{config}.  It can
also be generate from the Swing GUI using the button {\bf Sign
  Updates} found under the tab {\bf Updates}, under the tab {\bf
  Settings}, when one specifies an unexisting file to the popup
requesting a file with a Trusted key.  Note that to arrive there one
has to pass an updates file (e.g., as one generated with the following
scripts described below).

By default, the trusted key is RSA with 4k bits. That can be changed by changing the 
implementation of the method \cls{DD}.\mth{createTrustedSKFile()}.

Further, one can generate a release using the scripts in the folder {\bf installers/DD\_P2P} on the github
repository. The sample script {\bf ./installers/DD\_P2P/mk\_dist\_full\_DD.sh} must be executed giving it as parameter the curent version of the release, which has to be identical with the String in \cls{DD}.\mmb{VERSION}.
That script contains in fact an example of parameters for executing {\bf ./installers/DD\_P2P/mk\_dist.sh}.
A release generation should specify the parameters for qualities of test and amount of test that the
author of the release evaluates, rather than the values hardcoded in the script {\bf ./installers/DD\_P2P/mk\_dist\_full\_DD.sh}.

The file ``Trusted64.sk'' must be placed in the same folder with these scripts, prior to running them.
Also, the updated ``createEmptyDelib.sqlite'' file with the DDL of the database must be placed
in the subfolder {\bf 0.0.00}, while the latest ``DD.jar'' file obtained by compiling the project 
must be placed in {\bf 0.0.00/jars/}. Any other updated file must be placed in the relative
folder position where it is expected to appear in the installation/update package.

After all files are in placed according to these recommendations, the script {\bf mk\_dist.sh}
is executed as per the above recommendation, and the system will generate a folder with the
name of the release version, and two archives with the name composed of the prefix {\bf ddp2p\_}
and followed by the version number. The folder contains the package for automatic updates,
while the archives contains the release file for first installations.

The content of the created folder can be uploaded on mirror used for automatic updates,
while the file {\bf DD\_Updates.signed} found in that folder has to be copied outside that folder
at the URL that is specified as mirror inside the DDP2P system.

Mirrors can compose the updates folders coming from different testers by merging the tester part
of the text files, as long as the binary files are identical.

\section{Overall Structure}

Instructions to work with the code in Eclipse are available in the file: {\tt instructionsEclipseSetUp.pdf} on github, prepared by Song Qin.

The code consists of:
\begin{itemize}
\item a main engine that was tested on Android, Linux, Windows, MacOS.
\item GUI interfaces: we have developed an interface in Java Swing (under package {\tt widgets}), and a beginning of an interface on Android (development led by Dong Hang). GUI interfaces can start the engine and then be attached to it by registering an implementation of the interface {\tt config.Vendor\_GUI\_Dialogs}.
\item Database modules: currently we have three database modules supporting sqlite-jdbc, sqlite-4-java (needed for upgrades on MacOS), and an interface to the Android sqlite.
\item Plugins: we currently have two plugins for PC (a chat application, and a game) and a plugin for Android. The game plugin works with the version 1 of the DDP2P, and has to be recompiled to work with version 2 (no big changes should be needed, but menus now subclass a different type).
 
The plugins can be loaded dynamically from any {\tt .jar} file found in the {\tt plugins} folder, but can also be linked in the code, by calling a static method {\tt loadPlugin} 
in the class {\tt PluginRegistration} of package {\tt plugin\_data}, namely:\\
 {\tt plugin\_data.PluginRegistration.loadPlugin(Class<?> plugin, String peer\_GID, String peer\_name).}

The dynamic loading is performed at startup (or when called from GUI), and happens in:\\
 {\tt plugin\_data.PluginRegistration.loadPlugins(String peer\_GID, String peer\_name).}

In these methods, the {\tt peer\_GID} and {\tt peer\_name} are the {\tt GID} and name for the current peer.
Simple educational plugins are in the {\tt Hello} examples in folder {\tt plugins}, as well as in the package {\tt AndroidChat}. 
\item Installers and tools: we have some scripts to create release packages ({\tt installers/DD\_P2P}), merge databases of existing installations {\tt merge\_databases/Seo}, etc.
\end{itemize}

\section{Debugging}

Almost each class has the constants {\tt DEBUG} and {\tt \_DEBUG}. Typically {\tt DEBUG} is false and {\tt \_DEBUG}  is true.
Printing run-time information is done with {\tt if (DEBUG) System.out.println("CLASS\_NAME: METHOD\_NAME: message")}. 

Sometimes for debugging a class I either:
\begin{itemize}
\item
set its {\tt DEBUG} to true
\item
set some of its {\tt if (DEBUG)} into {\tt if (\_DEBUG)}.
\item
a local variable is declared in the debugged method  {\tt boolean DEBUG = true}
\end{itemize}

\section{Known Bugs}

It seems existing {\tt D\_Witness} objects signature fails. Have to check if it is due to old bugs when they were made, or something newer.

Motions are not synchronized. Have to check the corresponding class in the streaming {\tt package}, see if they are correctly queried.

\chapter{Architecture}
\section{Structure of Main Engine}

The engine is composed of a set of libraries (packages) for maintaining data structures for the managed items, as well as servers and clients
for exchanging this data. This engine is independent of database and of GUI. These libraries are compiled into DD\_Android.jar.

\paragraph{Using Databases, Email and GUI}
To be independent of database, this whole code uses an abstract database interface defined in \pkg{util}.\cls{DBInterface}, which
itself uses an abstract class \pkg{config}.\cls{Vendor\_DB\_Email}. Applications using a database or email must instantiate
\pkg{config}.\cls{Application\_GUI}.\mmb{dbmail} with an instance of this class. For example on Linux/Mac/Windows we use \pkg{util}.\pkg{db}.\cls{Vendor\_JDBC\_EMAIL\_DB} which is based on jdbc for sqlite, javax.mail.jar, sqlite-jdbc-3.7.2.jar.
On Android we use (see android code)...

To be independent of GUI, the warnings and notifications of data arrivals to GUI are done via an abstract GUI interface class
\pkg{config}.\cls{Vendor\_GUI\_Dialogs}. Applications using some GUI for notifications must instantiate
\pkg{config}.\cls{Application\_GUI}.\mmb{gui} with an instance of this class.  On standard Oracle java systems we use: 
\pkg{widgets}.\pkg{components}.\cls{GUI\_Swing}, whose static method \mth{initSwingGUI} does the job.

\paragraph{Main Application and Tools}
The entry points for various tools and GUIs are in the subpackages:
\begin{itemize}
\item
 \pkg{widgets} : if they use GUI
\item
 \pkg{util}.{tools} : if they use databases but no GUI
\item
 \pkg{tools} : if they need no database and no GUI (e.g. tools related to digital signatures and keys). Here there still are some old tools
 that need databases and GUI and need to be moved to the appropriate package (and to be changed by adding the aforementioned code for initializing the database and GUI drivers).
\end{itemize}

\paragraph{Initialization of Identity}
The communication servers need to know what is the identity of the current peer (to sign sent messages). This identity
is loaded from a database using any one of the static methods:
\begin{itemize}
\item
\pkg{config}.\cls{Identity}.\mth{getCurrentPeerIdentity\_QuitOnFailure()} which may try to use GUI to create or load the peer from a file if the database does not specify
the current peer, and it exits with \mth{System.exit()} if no peer is established.
\item
\pkg{config}.\cls{Identity}.\mth{getCurrentPeerIdentity\_NoQuitOnFailure()} which may try to use GUI if the database does not specify
the current peer.
\item
\pkg{config}.\cls{Identity}.\mth{init\_Identity(boolean quit\_on\_failure, boolean set\_peer\_myself, boolean announce\_dirs)}. 

	\begin{itemize}
	\item
	When setting the parameter \mmb{quit\_on\_failure} to true it will try to use GUI if the database does not specify a peer, to create
	or load the current peer from a file. 
	\item
	When setting the parameter \mmb{set\_peer\_myself} to true, this will also initialize a \pkg{data}.\cls{HandlingMyself\_Peer}.\mmb{\_myself} peer (the one used for signing messages),
	otherwise it just loads the data from the database with no other attempt to create the peer structure or to query the user with GUI for a 		peer
	when this is not found in the database.
	\item
	When setting the parameter \mmb{announce\_dirs} to true, the obtained peer and its addresses are sent to any directory
	in the list of directories loaded from the database.
	\end{itemize}
\item
\pkg{data}.\cls{HandlingMyself\_Peer}.\mth{loadIdentity(null)}. Same as the above call with all parameters set to false.
\item
\pkg{data}.\cls{HandlingMyself\_Peer}.\mth{get\_myself\_or\_null()}. Returns the currently set peer identity, or null if none was set.
\item
\pkg{data}.\cls{HandlingMyself\_Peer}.\mth{get\_myself\_with\_wait()}. Returns the currently set peer identity, or
on null it waits indefinitely for one to be set (e.g. by the GUI interaction n the aforementioned methods).
\end{itemize}

\paragraph{Initialization of Directories}
To enable communication to roaming peers and peers behind NATs, such peers need help from {\em access points} (aka {\em directory} or {\em supernode}).
A peer with a static IP does not need such a directory! In fact it can volunteer to act as an access point for others
(and may get incentives for it, see the IEEE-P2P14 article).
Each peer can set-up such access points or select from existing ones and present it as its address.
From that moment the peer would need to keep announcing its current roaming position (IP address) to that access point.

Currently selected access points can be loaded from the database using the static method:
\pkg{config}.\cls{DD}.\mth{load\_listing\_directories()} which can generate exceptions, or from
\pkg{config}.\cls{DD}.\mth{load\_listing\_directories\_noexception()}. They are made available to
the code via the static data structures \pkg{config}.\cls{Identity}.\mmb{listing\_directories\_xxx} where \mmb{xxx} is \mmb{inet}, \mmb{addr} or \mmb{string} which contain the data
as \pkg{hds}.\cls{Address} structures, as resolved internet addresses for making sockets ready for communication, or as strings ready for pretty printing.

\section{Connections}
The communication in DDP2P can be based on any of the Internet technologies called TCP and UDP. The communication code is found in the package \pkg{hds}, while
the code to build messages and to integrate incoming  messages is found in the package \pkg{streaming}.

A module exists for broadcasting over Adhoc WIFI using UDP broadcast (see packages \pkg{wireless}, \pkg{widgets.wireless}, and \pkg{handling\_wb}).
The module was built under the master thesis of Osamah Dhanoonn and during the last experiments it had some useful
general parts commented
out for faster hard-coded configuration of some experiments. Somebody should take time to reverse that process and replace the
hard-coded shortcuts with the original general procedures.

Hopefully that should be done when the broadcasting module is tested for Android, or when it is extended to Bluetooth communication.


\section{Streaming}

\subsection{ASN1 Tags}
There are various types of messages and the server distinguish them based on ASN1 tag. Each message in DDP2P is
encapsulated as an ASN1 object using our own implementation of ASN1 standard found in package \pkg{ASN1}.
This implementation was not tested to be compatible with the standard but was tested only for the correct invertibility of the
encoding and decoding, as well as for the DER minimality and determinism of the encoding (for usage with digital signatures).
Implementation of explicit tags was not done, even if it is relatively trivial from the available primitives.

\paragraph{ASN1 \cls{Encoder}}
In principle, a container sequence is created with \mth{initSequence()} on an empty ASN1 \cls{Encoder} object.
Elements are added to this sequence using \mth{addToEncoder()} functions. There exist \mth{Encoder} constructors for
most primitive types: \cls{boolean, int, byte, BigInteger, String, byte[], double}. A parameter 
\cls{Calendar} is for obtaining an ASN1 GeneralizedTime. The \cls{Encoder} class provides the static method \mth{getGeneralizedTime(Calendar)}
to convert between types Calendar and String in the GeneralizedTime format.
Use \mth{getNullEncoder()} or \mth{new Encoder().setNull()} to create a NULL tag.


A tag for the Encoded data can be set with the various \mth{setASN1Type} methods.

To get an Encoder for ASN1 BITSTRING use the method \mth{get\_BIT\_STRING(byte[])} since the constructor
with parameter byte[] is used for OCTET STRING.
The constructors Encoder(BigInteger[]) and Encoder(int[]) build an encoding of an ASN1 OID. To encode
arrays of integers or arrays of BigInteger you must used the functions described below!

The \mth{getEncoder()} static functions are used to create homogeneous sequences from arrays or ArrayLists.
When the elements of these vectors are not primitive, then they must be extending the abstract class \cls{ASNObjArray},
and must be implementing the optional \mth{instance()} method of that abstract class.
For primitive elements of the arrays one can use \mth{getBNsEncoder(), getStringsEncoder(), getStringEncoder(), 
getEncoderArray()}, handling BigInteger[], ArrayList<String>, String[], int[] or float[]

One can encode hashtables Hashtable<String,String> using \mth{getKeysStringEncoder()} or \mth{getHashStringEncoder()}.
The second variant encodes both the key and the value, sorted by the key. The first variant encodes just the keys,
placing them at positions defined by a function based on the value.

To get the array of bytes serialization from an ASN1 \cls{Encoder} one calls its method \mth{"getBytes()"}.
Directly from a class implementing the ASNObj abstract class, the DER serialization is obtained using
the method \mth{encode()}, or the calls \mth{getEncoder().getBytes()}.

\paragraph{ASN1 \cls{Decoder}}
Our ASN1 \cls{Decoder} works similarly. A \cls{Decoder} object is constructed based on an array of bytes. From a constructed object (SEQUENCE)
one removes the outer envelop with the method \mth{getContent()}.
Further the \cls{Decoder} of each element is obtained with \mth{getFirstObject(extract)}. The parameter must be "true" for the object to be extracted from the stream (such that we get the next element at the next call).
Here there are also separate member function to extract primitives from the current \cls{Decoder} (if it is for a primitive element).
\begin{itemize}
\item
\mth{getInteger()} returns a BigInteger
\item
\mth{getString()} returns a String
\item
\mth{getBytes()} returns byte[]
\item
\mth{getOID}, \mth{getBNOID()} returns an OID as int[], or BigInteger[], respectively
\item
\mth{getBoolean()} returns boolean
\item
\mth{getGeneralizedTime(), getGeneralizedTimeCalender()} returns a generalized time as String or Calender, respectively.
\item
\mth{ getReal(), getFloatsArray(), getIntsArray, getBNIntsArray(), getAny()} returns double, float[], int[], BigInteger[], byte[], respectively.
The encoding of reals/floats is not standard!
\end{itemize}
Each of these functions throws an exception \cls{ASNLenRuntimeException} if the encountered byte type is not the same as the native one
for the corresponding primitive. Optionally they can get a parameter of type byte which specifies the expected type byte 
for the data to be decoded. Some have a discouraged extra version that accepts to decode data of any type without error (and
typically are recognized by the suffix AnyType added to the aforementioned method names). A similar type byte can be
passed as a parameter of getFirstObject


Homogeneous arrays are obtained with factories \mth{getSequenceOf[AL|BN]} that receive as parameter an instance of the array and/or an
instance of the ASN1 object type to be decoded in the array.

\begin{verbatim}
// The next class implements the following ASN1 definition
// MyASNObj := SEQUENCE {
//     val [0] IMPLICIT INTEGER
// }
class MyASNObj extends ASNObjArrayable {
  int val = 1;
 MyASNObj instance() {return new MyASNObj();}
 @Override
 Encoder getEncoder() {
  Encoder enc = new Encoder().initSequence(); // creates SEQUENCE
  enc.add(new Encoder(val).setASN1Type(DD.TAG_AP0)); // IMPLICIT [0] INTEGER
  return enc.setASN1Type(getASN1Type);
 }
 @Override
 MyASNObj decode(Decoder dec) {
   Decoder decoder = dec.getContent; // remove the SEQUENCE envelope
   val = decoder.getFirstObject(true).getInteger(DD.TAG_AP0).intValue();
 }
}

// The next class implements the message definition
// Message := SEQUENCE {
//   obj [1] SEQUENCE OF MyASNObj
// }
class Message extends ASNObj {
 MyASNObj obj[];
 @Override
 Encoder getEncoder() {
  Encoder enc = new Encoder().initSequence(); // creates SEQUENCE
                           // obj IMPLICIT [1] SEQUENCE OF MyASNObj
  enc.add(Encoder.getEncoder(obj).setASN1Type(DD.TAG_AC1)); 
  return enc.setASN1Type(getASN1Type);
 }
 @Override
 Message  decode (Decoder decoder) {
  Decoder content = decoder.getContent();
  obj = content.getFirstObject(true, DD.TAG_AC1)
   .getSequenceOf (
     MyASNObj.getASN1Type(),
     new MyASNObj[0], 
     new MyASNObj);
   return this;
  }

  // The next method is an example of usage of the class to decode a message
  static Message extract(byte[] message) {
  return new Message().decode(new Decoder(message));
 }
 byte[] serialize() {
  return encode(); // or return getEncoder().getBytes();
 }
\end{verbatim}

Objects of type Hashtable<String,String> are obtained with factory \mth{getSequenceOfHSS} that receives as parameter 
a type of each element. These are encoded sorted by the key.

Non-primitive objects that extend ASNObj are typically decoded by creating an empty instance with an empty constructor or factory,
and then calling their member method \mth{decode()} giving as parameter the decoder of the structure obtained with one of the aforementioned methods (constructor from array of bytes or extraction from a decoder with \mth{getContent()} or
\mth{getFirstObject()}.

The type/tag of the object that will be extracted next can be queried on a \cls{Decoder} object using the methods:
\begin{itemize}
\item
\mth{isFirstObjectTagByte(tag)}.
Which returns true if the next object has the type byte equals to the parameter.
\item
\mth{getTypeByte()}, \mth{type()}
Return the type byte.
\item
\mth{getTagValueBN()}, \mth{tagVal()}
returns the tag value as a BigInteger, or an int strictly smaller than 31, respectively.
\item
\mth{typeClass()}, \mth{typePC()}
returns the class and class type values as {\tt int}s.
\end{itemize}

\subsection{Streaming Threads}
The streaming of data between DDP2P peers is managed by the following threads (classes in package \pkg{hds}):
\begin{itemize}
\item
\cls{Connections}. This thread manages a data structure with all the known addresses of all the peers ("safes") that we are currently polling (i.e., "used" peers).
\item
\cls{Client2}. This thread uses the data structure maintained by \cls{Connections} to poll peers in a loop based on TCP or UDP. This is a new
version replacing \cls{Client1} which was not using a \cls{Connections} data structures, but rebuilt it herself at each polling round.
\item
\cls{UDPServer}. This is the UDP server thread that listens for connections on a port. To send messages one uses the same 
UDP port (socket). 

\item
\cls{UDPServerThread}. This is a thread launched from \cls{UDPServer} to handle a given incoming datagram. Since
datagrams are limited in size. If incoming messages are of type \cls{UDPFragment}, then they are assembled. Only when
the whole message is assembled, then it is interpreted further and handled.
\end{itemize}

\subsection{Handling Fragments}
To send large messages one can use the method \pkg{hds}.\cls{UDPServer}.sentLargeMessage(),
which breaks them into blocks of size MTU and encapsulates each of them in a \pkg{hds}.\cls{UDPFragment} and in a UDPMessage.

Ar the receiving end, fragments are assembled in the \cls{UDPServer}.\mth{recvMessages} list of \cls{UDPMessage}.
The lists of received fragments are reevaluated in each loop of the \cls{UDPServer} thread, with the method \mth{sendFragmentReclaim()}
which builds a list of messages expired and reclaimes them. 

They are reevaluated also at each loop of the UDPServerThread when  in \mth{handleRequest()}
the peer is checked with \cls{UDPServer}.\mth{transferringPeerAnswerMessage()} for the existence of other ongoing messages towards the same destination (to avoid sending parallel answers to \cls{SyncRequest}, which would be redundant).

Both sending and receiving messages are reevaluated from \cls{UDPServer}.\mth{transferringPeerMessage()}
which is used from \cls{UDPServerThread}.\mth{handleSTUNfromPeer} to check for duplicates before sending messages SyncRequest.

A peer send only a limited number of fragments at a time (\mmb{DD.FRAGMENTS\_WINDOW}=10).
More fragments are sent when \cls{UDPFragmentAck} objects are received witnessing the array of fragments delivered
so far (and which are sent on receiving the fragments or on reclaim).
When the acknowledgements testify that all fragments were received we free the buffer.

Under the tag of a reclaim, \mmb{DD.TAG\_AC16}, the peers also send a  \cls{UDPFragmentAck} after an expiration of waiting time.
If the message reclaimed is found to be a zombie (a message believed sent and removed from the system) then a NACK is sent
to the remote peer. Zombies may exist because either an ack was duplicated and when the latter duplicates arrive the message's
arrival was already known, or because some fragment was duplicated and the recipient started to store it as a new message
whose other fragments never arrive (having been acknowledges and received once).

\chapter{Connection Data Structure}

In a diagram, the main hierarchy of data structures explained below could be represented as:

\noindent
\strut\cls{Connections}\\
\strut~\mmb{used\_peers\_xxx,  myselfPeer\_HT\_IPPORT\_CPD} $\rightarrow$\\
\strut~~\cls{Connection\_Peer}\\
\strut~~~\mmb{instances}  $\rightarrow$\\
\strut~~~$|$~\cls{Connection\_Instance}\\
\strut~~~$|$~~\mmb{peer\_directories}  $\rightarrow$\\
\strut~~~$|$~~$|$~\cls{Connections\_Peer\_Directory}  \\
\strut~~~$|$~~$|$~~\mmb{supernode\_addr, reported\_peer\_addr}  $\rightarrow$\\
\strut~~~$|$~~$|$~~~\cls{Address\_SocketResolved\_TCP} \\	
\strut~~~$|$~~\mmb{peer\_sockets, peer\_sockets\_transient}  $\rightarrow$\\
\strut~~~$|$~~~\cls{Connections\_Peer\_Socket}\\
\strut~~~$|$~~~~\mmb{addr}  $\rightarrow$\\
\strut~~~$|$~~~~~\cls{Address\_SocketResolved}\\	
\strut~~~\mmb{shared\_peer\_directories}  $\rightarrow$\\
\strut~~~~\cls{Connections\_Peer\_Directory}  \\
\strut~~~~~\mmb{supernode\_addr, reported\_peer\_addr}  $\rightarrow$\\
\strut~~~~~~\cls{Address\_SocketResolved\_TCP} \\	

\paragraph{Status of Polled Peers}
The \pkg{hds}.\cls{Connections} class keeps in static members the data describing the addresses and resolved sockets of the currently
polled remote peers.
The corresponding data structure elements are:
\begin{itemize}
\item
\mmb{myselfPeer\_HT\_IPPORT\_CPD}. This is a hashtable mapping the string obtained by concatenating the IP and PORT
of each of my listing directories to an object of type \cls{Connections\_Peer\_Directory} for that directory.
The object is placed in this hashtable when an answer from a directory comes containing my own peerGID and instance name.
\item
\mmb{my\_directories\_AL}. This is an \cls{ArrayList<My\_Directory>} for all my listing directories. Its updating and usage not yet implemented as of 12/28/2014.
\item
\mmb{used\_peers\_AL\_CP}. Is an \cls{ArrayList<Connection\_Peer>}, one for each of the peers being currently polled.
\item
\mmb{used\_peers\_GID\_CP}. Is an \cls{Hashtable<String,Connection\_Peer>}, with an entry for each of the peers being currently polled.
It maps the global identifier (GID) of the peer to the connection data for that peer.
\item
\mmb{used\_peers\_GIDH\_CP}. Is an \cls{Hashtable<String,Connection\_Peer>}, with an entry for each of the peers being currently polled.
It maps the hash of the global identifier (GIDH) of the peer to the connection data for that peer.
\item
\mmb{peersAvailable} simply caches the number of peers in \mmb{used\_peers\_AL\_CP}.
\end{itemize}

\paragraph{Status of the Data Manager}
For managing the updates needed to be performed to the above structures, we use the following:
\begin{itemize}
\item
\mmb{update\_dirs} tells that some modifications were made to my listing directories.
\item
\mmb{update\_peers} tells that some modifications were made in my database to the peers that we are polling, and the connection
structures need to be updated.
\item
\mmb{update\_needing\_peer\_connections} is a list of objects of type \cls{Connection\_Peer} that were inaccessible at the last
poll attempt, and therefore whose directories should be queried for updates. Its modifications is synchronized on
\mmb{lock\_update\_needing\_peer\_connections}.
\item
\mmb{lock\_used\_structures} is a monitor for synchronizing changes to the \mmb{used\_peers\_xxx} data structures.
\item
\mmb{monitor\_integrateDirAddresses} is a monitor for synchronizing changes due to incoming data from directories. I believe it
should be replaced with \mmb{lock\_used\_structures}, where there is time to test such changes!
\item
\mmb{monitor\_wait\_obj} is a monitor on which the connections maintaining thread is waiting to be notified of changes or timeout.
Timeouts may not be really needed since any change or failure is found separately.
\end{itemize}


When the connection manager thread updates its data structures, it does not do so concurrently with the \cls{Client2} thread
that uses this structures, since both processes could be long and synchronization between them could be slow or complex.
Therefore we have opted for implementing it by having the manager create the update into a set of temporary structures,
which are later switched with the ones actually accessed by end-user processes.

\paragraph{Working Data Structures}
Therefore the \cls{Client2} thread accesses the above data structures while the \cls{Connections} creates the update in
the set of similar structures:
\begin{itemize}
\item
\mmb{tmp\_my\_directories\_AL}
\item
\mmb{tmp\_used\_peers\_AL\_CP}.
\item
\mmb{tmp\_used\_peers\_GID\_CP}
\item
\mmb{tmp\_used\_peers\_GIDH\_CP}
\item
\mmb{tmp\_peersAvailable}
\end{itemize}
At the end of the update, the data structures are swapped, ad the is the only time when the \cls{Connections} thread needs to 
hold the lock of \mmb{lock\_used\_structures}. The user thread \cls{Client2} should create its copy of this set of structures 
at the beginning of each loop, which would also reduce its need of synchronization to a short time (we have to check that 
we are doing so).

While the \cls{Connections} is creating the new data structure with fields updated from the database changes, various
status flags and logs may be changed inside the currently used data structure based on the events on the network
(e.g., flags about the connection attempts and their success, as well as new socket and NAT addresses 
obtained from directories). To correctly integrate these flags into the new data structures build built,
the updatable structures are grouped in objects that can be directly linked from the new data. This way the updates
happen simultaneously in the old and the new structures.

New uncertified sockets and new instances received from the directories (that are not yet on the disk) have to be 
linked into the new data structure. Currently new instances received from directories are directly stored in database (table "peer\_instance")
but that may not be needed and in fact may be counterproductive since it is hard to avoid attacks with spam
without requiring signatures certifying each directory information (which would slow down the system). Either
that saving should no longer be done until the peer instance contacts us itself with a digitally signed information,
or saving should also store the directory server announcing the instance to help trace attacks.

\section{Data Types for Connections}


\subsection{\cls{Address}}
An \cls{Address} defines away to contact a peer or a directory, and consists of:
\begin{itemize}
\item
\mmb{domain}: host or IP address
\item
\mmb{tcp\_port}, \mmb{udp\_port}: the ports for TCP and UDP servers
\item
\mmb{pure\_protocol}, \mmb{branch}, \mmb{agent\_version}: together these define the type of the messages understood by the peer
\item
\mmb{instance},  \mmb{certified}, \mmb{name}: with local informative value. Each address may be associated with a given 'instance' (rather than being a generic directory for the peer, or a static address of a peer with a single instance). Only the certified addresses are to be stored in database table 'peer\_address'. The name is typically used to easily identify directories.
\item
\mmb{active} used for my listing directories to tell whether I am currently announcing myself to this address.
\item
\mmb{priority} used to deterministically order the addresses in ASN1 encoded sequences for correct verification of digital signatures.
It could also be used by clients as an order of testing addresses. 
\item
\mmb{inetSockAddr} used with my listing directory servers (where the tcp and udp ports are the same), to cache their socket. It
is initialized in \pkg{config}.\cls{DD}.\mth{load\_listing\_directories()}.
\end{itemize}

\subsubsection{\cls{Address\_SocketResolved\_TCP}}

This type of object hold:
\begin{itemize}
\item
\mmb{addr}: an address of type \cls{Address}
\item
\mmb{isa\_tcp}, \mmb{isa\_udp}:  cached socket addresses for TCP and UDP, respectively
\end{itemize}

\subsubsection{\cls{Address\_SocketResolved}}

This type of object hold:
\begin{itemize}
\item
\mmb{addr}: an address of type \cls{Address}
\item
\mmb{isa\_tcp}, \mmb{isa\_udp}:  cached InetSocketAddresses for TCP and UDP, respectively
\item
\mmb{ia}:  cached InetAddress
\end{itemize}

\subsection{\cls{My\_Directory}}
This structure (visibly not yet used) stores, for a directory listing me:
\begin{itemize}
\item
\mmb{supernode\_addr}: the \cls{Address\_SocketResolved\_TCP} socket address of the directory. Initalized in \cls{Connections}.\mth{init\_my\_active\_directories\_listings} but never used
\item
\mmb{reported\_my\_addr}: my (NAT?) \cls{Address\_SocketResolved\_TCP} socket address seen by the directory
\item
  \mmb{last\_contact}, \mmb{contacted\_since\_start}, \mmb{last\_contact\_successful}: date and flags of the last contact

\end{itemize}

\subsection{\cls{Connection\_Peer}}

All the connection data about a given polled peer is stored in an object of this type:
\begin{itemize}
\item
\mmb{peer}: the \cls{D\_Peer} object whose connections are described here.
\item
\mmb{shared\_peer\_directories}: the generic directories listed in peer, of type \cls{ArrayList<Connections\_Peer\_Directory>}, one for each
shared address of the peer that is of type DIR.
\item
\mmb{shared\_peer\_sockets}: the generic socket addresses listed in peer, of type \cls{ArrayList<Connections\_Peer\_Socket>}, one for each
shared address of the peer that is of type SOCKET.
\item
\mmb{instances\_AL}, \mmb{instances\_HT}: for each known instance of the peer there is a \cls{Connection\_Instance}
in the array list, and Hashtable, respectively. In the Hashtable, the instances are placed using as key the name
of the instance made non-null using the method \cls{Util}.\mth{getStringNonNullUnique()} (which is invertible with \mth{getStringNullUnique}).
The instances in the arrayList are sorted descending based on the number of objects exchanged so far.
\item
\mmb{status}: a structure (passed on update from old structures to new ones)  containing
 \begin{itemize}
 \item
  \mmb{contacted\_since\_start}, \mmb{last\_contact\_successful}: flags to tell the status of the last contact. These flags are encapsulated in the
status structure to easily pass them to the next updated version of the structure!
 \item
 \mmb{justRequestedSupernodesAddresses}: flag set to tell that directories were just asked for addresses by UDP, and should not
 send a new request (until \cls{Client2} finds that existing addresses are not yet working, i.e. each second attempt)

 The flag tells that the peer's directories were just asked by UDP for addresses in the previous iteration, and for at least one iteration of usage one can have patience for the UDP answer to arrive.
 \end{itemize}
\end{itemize}

\subsection{\cls{Connection\_Peer\_Instance}}
This structure stores the connection information related to a give clone (aka instance):
\begin{itemize}
\item
\mmb{dpi}: the database/directory information about this clone, of type \cls{D\_PeerInstance}.
\item
\mmb{peer\_directories}: the  directories listed in peer, of type \cls{ArrayList<Connections\_Peer\_Directory>}, one for each
instance address of the peer that is of type DIR.
\item
\mmb{peer\_sockets}: the socket addresses listed in peer, of type \cls{ArrayList<Connections\_Peer\_Socket>}, one for each
instance address of the peer that is of type SOCKET.
\item
\mmb{peer\_sockets\_transient}: the socket addresses received from directories for this instance, of type \cls{ArrayList<Connections\_Peer\_Socket>}, one for each volatile/transient
instance address of the peer that is of type SOCKET. 

Currently transient directories are not stored in separate lists (keeping an old implementation) and therefore 
there is a risk they can be lost when updating the structures (but we assume that transient directories will likely not exist and therefore
we do not take time now to implement a similar \mmb{peer\_directories\_transient} member).
\item
\mmb{status}: a structure (passed on update from old structures to new ones)  containing
 \begin{itemize}
 \item
	\mmb{contacted\_since\_start\_TCP}: set if there was a success of the TCP to this instance since start
 \item
	 \mmb{last\_contact\_successful\_TCP}:
            flags to tell the status of the last TCP contact attempt with this instance.
 \item
 	\mmb{ping\_pending\_UDP}: flag to tell whether there was a UDP ping sent to this instance without answer so far
 \item
	\mmb{last\_contact\_date\_UDP}: flag to tell the last date when aping reply came from this instance
 \end{itemize}
\end{itemize}

\subsection{\cls{Connections\_Peer\_Socket}}
This structure stores all the information needed to keep track of the status of the connection with a given socket address (typically for an instance, but generic ones may exist if the peer has a single instance). It holds:
\begin{itemize}
\item
\mmb{addr}: is an object of type \cls{Address\_SocketResolved} containing an address and its resolved sockets.
\item
\mmb{address\_LID}: the local pseudokey of the address in the "peer\_address" table. A negative value testifies that this is a transient address.
received from a directory but not certified.
\item
\mmb{behind\_NAT}: true with transient addresses if there was a NAT address reported with this socket
\item
\mmb{\_last\_contact\_date\_TCP}, 
\item
\mmb{last\_contact\_successful\_TCP}, 
%\item
\mmb{contacted\_since\_start\_TCP}: date
and flags with the status of the TCP connection to this address
\item
\mmb{\_last\_ping\_sent\_date}, \mmb{\_last\_ping\_received\_date}: dates of the UDP connection to this address (when UDP connection was last attempted,  reply was last received).
\item
\mmb{replied\_since\_start\_UDP}:
This flag is redundant since it results from the existence of a value to  \mmb{\_last\_ping\_received\_date}.
\item
\mmb{last\_contact\_pending\_UDP}:
This flag is set iff any UDP ping was sent since the last UDP ping reply was received.
\end{itemize}

\subsection{\cls{Connections\_Peer\_Directory}}

This structure stores all the information needed to keep track of the status of the connection with a given listing directory of a given
peer/instance. It holds:
\begin{itemize}
\item
\mmb{supernode\_addr}: on abject of type \cls{Address\_SocketResolved\_TCP} that contains the resolved address of the directory server.
\item data structures concerning the connection via NAT addresses reported by this directory.
 \begin{itemize}
 \item
 \mmb{\_reported\_peer\_addr}: a hashtable mapping "instance" names for a peer into objects of type \cls{Address\_SocketResolved\_TCP} that contains the resolved address of the NAT entry to that "instance", as reported by this directory. Instance names are translated in non-null
versions using Util.getStringNonNullUnique().
 \item
 \mmb{\_reported\_last\_contact\_date}: a hashtable mapping "instance" names for a peer into objects of type String holding the GeneralizedTime of the last time a ping reply was received for the NAT address reported for that instance by this directory.
 \item
 \mmb{\_reported\_last\_ping\_pending}: a hashtable mapping "instance" names for a peer into objects of type \cls{Boolean} which are
set to TRUE if a ping request was sent for the NAT address reported by this directory since the last reply, and to FALSE or null otherwise.
 \end{itemize}
\item
\mmb{\_last\_contact\_TCP}, \mmb{contacted\_since\_start\_TCP}, \mmb{last\_contact\_successful\_TCP}: date and flags for the connection
status via TCP to this directory when querying addresses of the current peer.
\item
\mmb{\_last\_contact\_UDP}, \mmb{contacted\_since\_start\_UDP}, \mmb{last\_directory\_address\_request\_pending}: date and flags for the connection
status via UDP to this directory when querying addresses of the current peer.
\item
\mmb{address\_LID}: the local pseudokey in the database table "peer\_address" for the data associated to this directory. Set to -1
if this is a transient directory, i.e., received from a directory.
\item
\mmb{reportedAddressesUDP}: an object of type \cls{ArrayList<Address>} with the complete list of addresses received over UDP from
this directory for the current instance. Used in displays, in the widget \cls{DirectoryPing} with status of directories,
and as temporary answer from this peer when doing a UDP request.
%
%This is {\bf deprecated} Could be replaced by \mmb{lastAnswer} when time allows.
\item
\mmb{lastAnswer}: this is the whole last answer received from this directory over UDP. It is used only for shared directories to retrieve
the last know list of addresses from an instance as temporary answer to an UDP request or for display in the \cls{DirectoryPing}.
\end{itemize}

\section{Connections Update Process}
The simplified diagram of this process is shown in Figure~\ref{fig:conn_update}.
\begin{figure}[!ht]
\noindent
\noindent
\strut\cls{Connections}.\mth{\_\_run} \\
\strut~init \\
\strut~wait\_updates (locking lock\_updates\_pc, check changes in dirs, peers, update\_pc) \\
\strut~ updates\\
\strut~~ init \mmb{tmp\_xxx} \& switch \\
\strut~~$|$~ \mth{init\_used\_peers} \\
\strut~~$|$~~ for all \mmb{used\_peers} \\
\strut~~$|$~~~ \mth{loadAddresses\_to\_PeerConnection} \\
\strut~~$|$~~~~ links transient instances from old and, for all instances:\\
\strut~~$|$~~~~~ \mth{loadInstanceAddresses}  and links transient instances from old\\
\strut~~$|$~~~~~~ \mth{loadInstanceAddresses\_certified} and link transient addresses\\
\strut~~$|$~~~~~~~ \mth{locatePS} from old  or resolve addresses\\
\strut~~ for all \mmb{update\_needing\_peer\_connections} \\
\strut~~~ \mth{update\_supernodeaddress()} \\
\strut~~~~ \mth{update\_supernodeaddress\_instance()} \\
\strut~~~~~ \mth{update\_supernodeaddress\_instance\_dir()} \\
\strut~~~~~~ \mth{getDirAddress()} \\
\strut~~~~~~~ \mth{getDirAddressUDP()} only on the failure of TCP \\
\strut~~~~~~~~ \mth{getKnownDirectoryAddresses()} use old UDP addresses while expecting new ones \\
\caption{\cls{Connections} maintenance}\label{fig:conn_update}
\end{figure}
The connections update process consists of a loop. 
An initial initialization in \pkg{Connections}.\mth{init()} has as purpose is to make the 
structures non-null, and loaded from the database.

The loop waits on the monitor \mmb{monitor\_wait\_obj} until a change is signaled in the database, a connection fails, or until a timeout of amount \mmb{CONNECTIONS\_UPDATE\_TIMEOUT\_MSEC} (currently set to 3 minutes).
After each wake up, the method \mth{updates} is called.

The method \mth{updates} initializes the \mmb{tmp\_xxx} data structures in \cls{Connections} with the data in the database 
(as well as the data in the currently used data structures) and then uses them to replace the currently used data structures.

Further, if there are peer connections that did not work recently, these are updated by contacting to their directories and asking
new transient addresses, to be integrated in the data structures.


\section{Client Process}

\begin{figure}[!ht]
\noindent
\strut\cls{Client2}.\mth{\_\_run} \\
\strut~loop for each peer, until \mmb{turnOff} is set \\
\strut~~\mth{try\_wait} \\
\strut~~\mth{handlePeer} \\
\strut~~~\mth{handlePeerRecent()} \\
\strut~~~\mth{handlePeerNotRecentlyContacted()} \\
\strut~~~~\mth{trySocketsListTCP()} \\
\strut~~~~$|$~\mth{try\_TCP\_connection()} \\
\strut~~~~$|$~\mth{Client2.transfer\_TCP} \\
\strut~~~~$|$~~\mth{ClientSync.buildRequest()} \\
\strut~~~~$|$~~\mth{Client2.integrateUpdate()} \\
\strut~~~~$|$~~~\mth{UpdateMessages.integrateUpdate()} \\
\strut~~~~\mth{trySocketsListUDP()} \\
\strut~~~~$|$~\mth{try\_UDP\_connection\_socket()} \\
\strut~~~~\mth{try\_UDP\_connection\_directory()} \\
\caption{\cls{Client2} and connections structures}\label{fig:conn_client2}
\end{figure}

The \cls{Client2} loops over the available connections and for each of them attempts TCP and UDP connections,
and is shown in Figure~\ref{fig:conn_client2}.

By calling method \mth{Client2.try\_wait()} we make sure that
each peer is handled only when the load of the system in terms of number of \cls{UDPServerThread}s (based on \mth{UDPServer.getThreads()}) is below 
\mmb{UDPServer.MAX\_THREADS}/2 (currently 3=6/2). Otherwise a delay is set to \mmb{ClientSync.PAUSE}.
At the loop immediately after a wakeup request, the value of \mmb{Client2.recentlyTouched} is true.
The client thread also delays the same amount at the end of each loop if the \mmb{Client2.recentlyTouched} is not set.
The end of the loop is detected by comparison of the current peer index \mmb{peersToGo} with \mmb{Connections.peersAvailable}.

Once it is decided to poll some peer, this is obtained with \mth{Connections.getConnectionAtIdx(peersToGo)},
and handled with \mth{handlePeer}. Further each peer is handled in this method separately based on whether it was
recently reached or not.

The methods \mth{handlePeerNotRecentlyContacted()}, and \mth{handlePeerRecent()} work by calling 
\mth{trySocketsListTCP()} (if \mmb{DD.ClientTCP} is set) and \mth{trySocketsListUDP()} (if \mmb{DD.ClientUDP})
is set. 
These methods attempt connections separately for each listed socket. 
If a TCP connection is successful, further connections are not tried for that peer.

In \mth{handlePeerRecent()}  the TCP sockets
are tried in the reversed order of the date of last connections. 
Both methods try TCP sockets in instances giving priority to the ones with which we exchanged
so far the largest number of items.

If trying UDP connections for an instance, the methods call \mth{try\_UDP\_connection\_directory} to also 
send pings using directories of the instance as well as the shared directories, as STUN servers.

\section{UDPServerThread Process}

\begin{figure}[!ht]
\noindent
\strut\cls{UDPServerThread}.\mth{\_\_run} \\
\strut~\cls{Connections}.\mth{acknowledgeReply()} on ping reply\\
\strut~\cls{Connections}.\mth{registerIncomingDirectoryAnswer()} on answer from server\\
\strut~~\mth{Connections.getConnectionSharedPeerDirectory()}\\
\strut~~for each instance\\
\strut~~~may update \mth{Connections.myselfPeer\_HT\_IPPORT\_CPD}\\
\strut~~~\mth{Connections.getConnectionInstancePeerDirectory()}\\
\strut~~~\mth{Connections.getConnectionPeer()} \\
\strut~~~build visualisation data in \mmb{D\_Peer.peer\_contacts} \\
\strut~~~\mth{getSocketAddresses\_for\_peerContacts\_widget()} \\
\strut~~~$|$~build visualisation data in \mmb{ClientSync.peer\_contacted\_addresses} \\
\strut~~~\mth{Connections.integrateDirAddresses()} \\
\strut~~~~\mth{Connections.locatePS()} \\
\strut~~~~\mth{Connections.locatePD()} \\
\caption{\cls{UDPServerThread} and connections structures}\label{fig:conn_udpserver}
\end{figure}
This process retrieves incoming datagram packets, and integrates them based on their type. The
algorithm is given in Figure~\ref{fig:conn_udpserver}.
If they are UDP ping sent by another initiator, then just a reply ping is sent.

When a reply is received to a ping sent my this agent as an initiator, then a \cls{SyncRequest} is sent back and 
also the connections structure is updated announcing of the success of the connection.

When an answer is received from a directory with the list of addresses of a peer, new transient addresses are added to the
corresponding place in the data structure. Also, NAT addresses reported are stored in the corresponding directory structure.
The directory sending the message is identified among the directories serving the peer mentioned in the reply, based on the
IP and port thereof, using methods \mth{Connections.getConnectionSharedPeerDirectory()} and \mth{Connections.getConnectionInstancePeerDirectory}. This can be improved in the future by adding the \mmb{address\_LID} of the directory in the exchange...

The \cls{UDPServerThread} then calls \cls{Connections}.\mth{registerIncomingDirectoryAnswer()}.
This method iterates over all in instances in the answer. If any reports the instance of the agent receiving the message,
the result is stored in \mth{Connections.myselfPeer\_HT\_IPPORT\_CPD}.

The results for each instance are stored in the corresponding \cls{Connection\_Peer} and \cls{Connections\_Peer\_Instance}s
obtained using method \mth{Connections.getConnectionPeer()} (old versions have used \mth{Connections.getConnectionPeerInstance()}. 
Significant code there deals with building the data structure used for visualization in \mmb{D\_Peer.peer\_contacts},
and \mmb{ClientSync.peer\_contacted\_addresses}.

The actual integration is done using method \mth{Connections.integrateDirAddresses()}, and is followed by waking up
the client using method \mth{Client2.touchClient()}.

The method \mth{Connections.integrateDirAddresses()} iterates over all the instances in the obtained structure and
tries to locate previous status objects using locatePS and locatePD. New addresses are stored in \mmb{peer\_sockets\_transient}
and \mmb{peer\_directories}. It also marks instances found, or no longer found, behind NAT.

\section{Starting the Connection Processes}

Each of the three main processes (UDPServerThread, Client2, Connections) can have only one instance 
running at a time in the system. Those instances can be accessed (as long as they are running) using
static members, and the starting/stopping of the processes should be preferably done using given static methods:
\begin{itemize}
\item
\cls{Client2}: The static reference to the unique instance of \cls{Client2} is in \cls{Application}.\mmb{g\_PollingStreamingClient} which is of type \cls{IClient} since at certain moments we supported in parallel several implementations of the client (\cls{Client1} and \cls{Client2}).
To start or stop the client use the static method \pkg{config}.\cls{DD}.\mth{startClient(boolean on)}. To wake up the client
that sleeps between two rounds of polling, use \cls{DD}.\mth{touchClient()}.
\item
\cls{Connections}: A static reference to this process is found in \cls{Client2}.\mth{g\_Connections}. It is started with \cls{Client2}.\mth{startConnections()}.
\item
\cls{UDPServer}: This is started with \cls{DD}.\mth{startUServer(boolean on, \cls{Identity} peer\_id)}. The unique instance in the system is linked into the static
\pkg{config}.\cls{Application}.\mth{g\_UDPServer} (where one can also find \cls{Application}.\mth{g\_TCPServer} and \cls{Application}.\mth{g\_DirectoryServer}).
\end{itemize}

\chapter{Data Objects}
The data exchanged between peers is organized into semantically independent units, each of them of manageable size.
Ideally this size should fit a small number of UDP datagrams, exchangeable in one round of communications between two peers found in
adhoc wifi contact between two cars running in opposite directions on a highway. In fact, an encounter may fit one or more such data items.

The data items exchangeable in DDP2P are:
\begin{itemize}
\item
peer (aka safe)
\item
organization of type authoritarian
\item
organization of type grassroot
\item
active constituent
\item
external constituent
\item
neighborhood
\item
witness stance
\item
motion
\item
justification
\item
signature
\item
news item
\item
translation item
\item
tester recommendation
\end{itemize}
Each of these items is identified by a unique global identifier (GID) whose construction algorithm depends on the type of item described.

Some items may have multiple interchangeable GIDs such as a public key and its secure hash with an agreed digest algorithm such as SHA1 (e.g., peers, authoritarian organizations, active constituents, tester items).

Agents may locally store only the GIDs of the data units of interest (or an indication of their existence, such as a hash of a bundle of GIDs),
while the actual data items may be stored on cloud and retrieved on need based on these GIDs.

The GID of some items may have a scope, being unique only in the context of some other object (e.g., active constituent GIDs
are unique only in the context of a given organization GID).

\section{Object Caches}

\subsection{Motivation and Status}
A caching mechanism was developped to speed up access to frequently
used objects such as: {\tt peers, organizations, constituents,
  neighborhoods, motions, justifications, directory entries, and
  recommendations of testers}.  Ideally all shared objects should be
made cachable, mechanism that would also permit easy implementation of
a cloud support.  In particular, if we ensure that any access to the
database is made via a small interface in the corresponding objects
(\cls{D\_Peer}, ...), then it is sufficient to change that interface
for supporting a cloud.

We have not yet implemented cache for some important shared objects,
such as: {\tt news, votes and witness}. The reason these were left behind, besides 
the lack of time, is that they are never needed except for:
\begin{itemize}
\item
shipping them to other peers, or 
\item for statistics, 
\end{itemize}
which is done acceptably well by database queries, when not the whole database
can fit in memory.

\paragraph{TODO:} A type of object that needs urgent cache support is the secret key.
The system has in its database a table for secret keys and this table 
is accessed each time signatures are generated or local ownership of a key
is verified. Ideally, if the set of known secret keys is small, then
it should be fully loaded into a cache, with a flag telling that
there is nothing else on disk. A simple cache is implemented by having peers,
organizations and constituents optionally cache their secret keys,
but this is less efficient then if a specialized cache would be implemented.

To implement caching we use a store consisting of a data structure
based on a doubly linked list and a set of hashtables.  Each type of
cashed object has its own such store, methods, and a thread that handles
data in that store.

\subsection{The Doubly Linked List}

We need a data structure with efficient (constant):
\begin{itemize}
\item
 access and removal of not recently used elements,
\item
 insertion of new elements as the most recently used,
\item
 tagging existing elements as recently used,
\item
 locate an item based on a key: local pseudokey (LID) or global identifier (GID).
\end{itemize}

The doubly linked list is a data structure that offers the first three properties,
and can be combined with hashtables to obtained the fourth property.

Java does not have an implementation of a standard doubly linked list.
Therefore we provide our own implementation based on the classes:
\begin{itemize}
\item
\pkg{util}.\cls{DDP2P\_DoubleLinkedList<T>} which encapsulates a
circulat doubly linked list with at least one element (\mmb{head})
that has an empty payload, and the \mmb{counter} of the number of used
nodes (all nodes except for the head must have a payload). 

Insertions are done in \mmb{head}.\mmb{next}, and removals of unused is done in \mmb{head}.\mmb{previous}.
Any used element is moved at retrieval after the \mmb{head}, to be marked as recent. 
It is expected that the type \cls{T} implements the interface
\pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node\_Payload<T>}.
Insertions are done with \mth{offerFirst()}, marking as recent with \mth{moveToFront()}, and removal with 
\mth{removeTail()} and with \mth{remove()}.
\item
\pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node<T>}
is a generic class defining the type of a node in the linked list. Besides the fields \mmb{next} and \mmb{previous},
it also has the field \mmb{payload} of type \cls{T}. It is expected that the type \cls{T} implements the interface
\pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node\_Payload<T>}.
\item
\pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node\_Payload<T>} is an interface for payloads of the
doubly linked list. The interface requires two methods whic are used to set and retrieve a
pointer from a payload to the instance of \pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node<T>} that
holds it. This pointer is used to locate the node of a used object, such that the node could be relocated to the head of the list.
\end{itemize}

\subsection{Payloads of Doubly Linked Lists}

Typically each of the cached object types such as \cls{D\_Peer}, \cls{D\_Organization}, \cls{D\_Constituent} .... 
implements the interface pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node\_Payload<T>}.

These classes have to implement the two methods of the interface pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node\_Payload<T>}.
To group most of the the members of the payload that are related to caching, a static class member is defined in
each of the cached objects. For example we have: 
\begin{itemize}
\item
\cls{D\_Peer}.\cls{D\_Peer\_Node}, 
\item
\cls{D\_Organization}.\cls{D\_Organization\_Node},
\item
\cls{D\_Constituent}.\cls{D\_Constituent\_Node}, 
\item
\cls{D\_Neighborhood}.\cls{D\_Neighborhood\_Node}, 
\item
\cls{D\_Motion}.\cls{D\_Motion\_Node}, 
\item
\cls{D\_Justification}.\cls{D\_Justification\_Node}, 
\item
\cls{D\_RecommendationOfTester}.\cls{D\_RecommendationOfTester\_Node}, 
\item
\cls{DirectoryServerCache}.\cls{D\_Directory\_Storage}.
\end{itemize}

The typical members of each of these are:
\begin{itemize}
\item
\mmb{loaded\_object}
is a static member holding the cache, i.e. the doubly linked list instance of \cls{DDP2P\_DoubleLinkedList<T>}.
\item
\mmb{current\_space}, is a static member holding the estimated RAM size of the current cache.
\item
\mmb{MAX\_TRIES} is a constant with the number of attempts to remove unused elements from the cache doubly linked list
when the size has grown more than the maximum allowed for this cache. At each attempt at most one element is removed from the
cache, if it is not locked for writing. Those locked for writing are moved to the front of the doubly linked list of the cache.
\item
\mmb{my\_node\_in\_loaded}
holds the pointer to the instance of \pkg{util}.\cls{DDP2P\_DoubleLinkedList\_Node<T>} in the doubly linked list of this cache.
\item
\mmb{message} is an ASN1 encoding of the cached object, to help having it ready for sending in messages.
TODO: when calling \mth{getEncoder()} on a cached object one should send this value instead of reencoding the object.
 \item
\mmb{loaded\_By\_LocalID}
is a \cls{Hashtable<Long,T>} mapping pseudokey identifiers of type \cls{Long} into cached objects found in the doubly linked list.
\item
\mmb{loaded\_By\_GID},
\mmb{loaded\_By\_GIDH}
are  \cls{Hashtable<String,T>} mapping global identifiers (GID) and their hashes (GIDH) of type \cls{String} into cached objects found in the doubly linked list.
\item
\mmb{loaded\_By\_GID\_ORG},
\mmb{loaded\_By\_GIDH\_ORG},
\mmb{loaded\_By\_ORG\_GID},
\mmb{loaded\_By\_ORG\_GIDH} are alternatives to the data structures mmb{loaded\_By\_GID} and
\mmb{loaded\_By\_GIDH}, that are needed for caches where the GIDs may repeat in different organizations.
This is the case of \cls{D\_Constituent}, where the GID is a public key that can be reused in different organizations.

Currently such hashtables are not needed for \cls{D\_Neighborhood}, \cls{D\_Motion} and \cls{D\_Justification}, where the
GIDs are currently computed by hashing the data of the object including the GID of the organization for which the object is relevant.
However these four structures are used in these cached types since we want to make it easy to experiment in the future
with implementations where objects are shared between organizations.

These alternative hashtables are of type \cls{Hashtable<String,Hashtable<Long,T>>} or \cls{Hashtable<Long,Hashtable<String,T>>} mapping global identifiers (GID) and their hashes (GIDH) of type \cls{String} into tables mapping LIDs of organizations into cached objects found in the doubly linked list.
\end{itemize}

\subsection{Locking Objects in Cache}

To avoid that an object is dropped from cached while being modified and not yet saved, a locking mechanism is implemented.
Each cached object has a member \mmb{status\_lock\_write} that is incremented by any thread that plans to modify the object
and is decremented after the modifications were finalized (and potentially a storing activity to permanent storage was scheduled).
This is accessed via  \mth{get\_StatusLockWrite()}, \mth{inc\_StatusLockWrite()} and \mth{dec\_StatusLockWrite()}.

For \cls{D\_Peer}, \cls{D\_Organization} and \cls{D\_Constituent} objects there is an additinal locking flag that avoids removing them
from the cache as long as they are delected as the {\em current} context for a GUI. This flag is \mmb{status\_references}
and is managed via \mth{get\_StatusReferences()}, \mth{inc\_StatusReferences()} and \mth{dec\_StatusReferences()}.

As long as one of these counters is positive, a cache does not drop the object, preventing conflics that would lead in duplicate
objects being modified concurrently and inconsistently for the same GID.

To increment the lock \mmb{status\_lock\_write} of an object, it has to be done when the object is queried from the cache (or added to the cache) via a factory of the object (generally the parameter \mmb{keep} of the factory). This lock is released by users based on calling \mmb{releaseReference()}. The \mmb{status\_references} lock can be raised while the
\mmb{status\_lock\_write} lock is raised.

If two different threads attempt to raise simultaneously the \mmb{status\_lock\_write} lock (raising it to values above 1),
it signals a potential bug. Always the first thread locking the object has its \cls{StackTraceElement[]} data stored in the field \mmb{lastPath},
such that it can be displayed for debugging if a second thread tries to lock the same object concurrently.
These tests are done under the synchronization of \mmb{monitor\_reserve}.

\paragraph{TODO:} Some of the caches may inverse the usage of the two locking means or use the name \mmb{status\_references} 
instead of \mmb{status\_lock\_write}. This should be checked and the names should be standardized!

\subsection{Hashtables of Cached Objects}
The hashables shown in the previous section are used to efficiently retrieve cached objects both by their LID and by their GID.
Whenever an object is created or read from the disk and registered in the cache, it is also linked into the corresponding hashtables.

Some objects are recently received or created and have GIDs but were not yet stored on the disk and therefore have no LID pseudokey at the
moment of their registration in the cache. Nevertheless they need to be registered in cache before saving them,
to make sure that we can lock them to avoid that two objects with the same GID are saved in parallel leading to
inconsistent databases or errors.

When registering an object that does not yet has a LID, that object is not linked into the \mmb{loaded\_By\_LocalID}
hashtable of the cache. As soon as the object is saved (while being locked), the method \cls{T}.\cls{T\_Node}.\mth{register\_newLID\_ifLoaded()}
is called via the method \mth{setLID\_AndLink} of the cached payloads, and it registers the LID in the hashtable, while
checking for potential bugs from illegal usage that would have resulted in duplications of cache for the same GID or LID.

Similarly, some objects are created and while they are being edited they do not yet have a GID (e.g., organizations, motions, justifications).
These {\em temporary} objects when they are registered in cache (to enable locking them for writing), they are not locked in
the corresponding hashtables for the GIDs. When the object editing is finalized by generating a GID, the object is linked
into the apropriate hashtables via the method \cls{T}.\cls{T\_Node}.\mth{register\_newGID\_ifLoaded()}, called from 
\cls{T}.\mth{setGID\_AndLink()}.

\subsection{Factories of Cached Objects}

Users are expected to obtained cached objects not via the private constructors that take as parameters LIDs and GIDs,
but via {\em factory} static methods. This is required in order to avoid duplicate instances for the same object, which could
lead to inconsistencies, and to ensure that cached versions are found and given priority to reloading from disk/cloud.

An empty constructor, available via a factory called \mth{empty()} is made available to be used when decoding
ASN1 messages, or when building new objects from scratch in the editor. Objects created in this way and that do not yet have 
a GID because they are temporary, are stored using the method
\mth{storeSynchronouslyNoException()}, and can later be loaded into the cache using the factory methods \mth{getXXXByLID(LID, ...)}

Objects created with empty constructors or factories and that have a GID
are then registered in the cache and saved by following the next steps (sometimes implemented in a method called  \mth{storeRemote()}):
\begin{enumerate}
\item
Query the cache by the GID using a factory with \mmb{create} and \mmb{keep} flags set, and when available in the factory, with the new object in the \mmb{storage}. If nothing was known about the requested object:
\begin{itemize}
\item if a no-null object is provided in parameter \mmb{storage}, then this object is linked in the cache, filled with the right GID, marked dirty, and returned. 
\item if no storage parameter is provided by the called, them a new object is created, with the GID set to the provided value, and 
marked dirty and temporary
\end{itemize}

Some factories can take as parameter both GIDs and GIDHs. Their types (GID vs GIDH) can be detected dynamically and GIDHs can be computed
by the factory from a provided GID.
\item
If the object returned was different from the one we need to save, then the content of the one we need to store is copied
into the one returned by the factory, e.g. using methods called \mth{loadRemote()}.

Typically \mth{loadRemote()} also checks first whether the new object is really newer or more complete then the previous
one by either checking if the old one was temporary or by comparing creation dates, quitting with false if parameter is not newer. 
If the object is filed with the parameter, then some dirty flags are set and the temporary flag
is also cleared.

The method \mth{loadRemote()} can detect when unknown objects are being referred (e.g. a justification regering the GID
of an unknown motion or constituent), and those GIDs are stored in the parameter \mmb{missing\_rq} bag,
to be requested from peers. Temporary objects with those GIDs are also created using apropriate factories.
GIDHs of newly obtained objects are returned in the parameter \mmb{sol\_rq} bag.
\item
If a dirty flag was set, then the cache saving threads are notified by calling \mth{storeRequest()} on the object.
\item
The object's lock is released using \mth{releaseReference()}. If this step is forgotten,
then when a new operation tries to lock the object, the cache with dump debugging information with the trace of the location
of the first locking operation to help in debugging. Also subsequent accesses are delayed for 5 seconds to try to avoid
accidental concurency.
\end{enumerate}

For example, the code for storing newly arrived justifications in \pkg{streaming}.\cls{WB\_Messages}.\mth{store()} is:

\begin{verbatim}
if (! j.isGIDValidAndNotBlocked()) continue;
// preparing management of missing/obtained GIDH
rq = missing_sr.get(j.getOrgGIDH());
if (rq == null) rq = new RequestData();
sol_rq = new RequestData();
new_rq = new RequestData();

// actual integration of a decoded justification "j" 
// assumed verified for signatures and blocking
D_Justification jus = 
       D_Justification.getJustByGID(
                 j.getGID(), true, true, true, peer, 
                 p_oLID, p_mLID, j);
if (jus == j) {
    jus.fillLocals(sol_rq, new_rq, peer);
    config.Application_GUI.inform_arrival(jus, peer);
    jus.storeRequest();
} else
  if (jus.loadRemote(j, sol_rq, new_rq, peer)) {
    config.Application_GUI.inform_arrival(jus, peer);
    jus.storeRequest();
  }
jus.releaseReference();

// management of new and missing GIDH
rq.update(sol_rq, new_rq);
missing_sr.put(j.getOrgGIDH(), rq);			
\end{verbatim}

For only reading the content of an object, it will be loaded by calling a factory based on the known LID or GID,
and without the \mth{keep} parameter set.

For reading and writing the contect of an object, it will be loaded by calling a factory based on the known LID or GID,
and with the \mth{keep} parameter set. After modification the user should set appropriate dirty flags, based on the parts of the object
that were modified, and should call the \mth{storeRequest()} method, followed by the \mth{releaseReference()}.
The \mth{storeRequest()} method should not be called if no change was made, but the \mth{releaseReference()} method must
necessarily be called to unlock the object.

If we already have a reference to an object before we decide that we need to lock it for writing, that can be achieved using
factories of the type \mth{getXXXByXXX\_Keep()} which try the cache all LID, GID and GIDH of the object passed in parameter,
before registering a new one. The actual such factories are called: \mth{getPeerByPeer\_Keep()}, \mth{getOrgByOrg\_Keep()}, ..., \mth{getJustByJust\_Keep()}

\paragraph{TODO:} Not all the pieces of code in \pkg{streaming}.\cls{WB\_Messages}.\mth{store()} are
so standardized as the one shown here, and the remaining ones should be brought
to such an optimized shape. Also, not all are yet tested for blocking and signatures or GID correctness.
With improvements, communication should be tested to see if synchronization work well after each change!

\subsection{Constants to Control Caching}

There are two Thread classes used for each cache type XXX: \cls{D\_XXX\_SaverThread} and 
\cls{D\_XXX\_SaverThreadWorker}. The first type of thread has a single running instance that wakes up
when notified by \mth{storeRequest()} or on timeouts and, when there are not too many running threads,
will create an instance of the thread of the second type which will store a dirty object from the cache.
Dirty objects are found in \cls{HashSet}s \mmb{\_need\_saving\_obj} and \mmb{\_need\_saving}
where they are placed by \mth{storeRequest()}. Historically, when the object has a GID/LID  is stored in the second of those hashsets
and otherwise in the first. 
\paragraph{TODO:} However not the distinction is would need to be reverified.

A set of constants are used to controll the behavior of the two threads that control the storing of each cache to the
permanent support (disk/cloud).
These constants are in class \cls{SaverThreadsConstants}. These constants control:
\begin{itemize}
\item
\mmb{MAX\_LOADED\_XXX}, \mmb{MAX\_XXX\_RAM} are user modifiable variables controlling
 the sizes of the caches. There is also a constant  \mmb{MIN\_LOADED\_XXX}
since it referes to the count of objects undre which the user-modifiable limit in \mmb{MAX\_LOADED\_XXX} is not considered.
\item
\mmb{MAX\_NUMBER\_CONCURRENT\_SAVING\_THREADS}:
 the maximum number of running saver threads instances of \cls{D\_XXX\_SaverThreadWorker}, over which new ones are not started.
\item
\mmb{SAVER\_SLEEP\_BETWEEN\_OBJECTS\_MSEC}: delay between launching threads when there are many waiting to be saved.
\item
\mmb{SAVER\_SLEEP\_WAITING\_OBJECTS\_MSEC}: delay between launching threads when there is none waiting to be saved.
\item
\mmb{threads\_xxx} number of threads for each given type xxx of cached objects. The total count is given by \mth{getNumberRunningSaverThreads()}.
\end{itemize}

\chapter{Streaming Logic}

Since each peer's database may be voluminous, we do not intend to have complete databases synchronized
at each interaction.
Rather we want at each TCP or UDP encounter to only exchange a token amount of information. For this purpose
a total order is defined on all semantically independent items of information of the database. This order is given by the
\mmb{arrival\_date} in the database, namely the date when the latest version of the item was locally defined (either by arrival 
from another peer, or by local construction). The resolution of this date in is terms of milliseconds. Due to limited precision
of the local clock, multiple items may have arrived at the same declared arrival time and therefore they would
have to be shipped together. To avoid large such clusters, we tend to artificially delay saving arrival objects with delays of a millisecond.
To force different items to have different arrival timestamps, the arrival timestamp of each item is generated using the
static method: \pkg{data}.\cls{ArrivalDateStream}.\mth{getNextArrivalDate()}, which sleeps 1ms when there is a conflict.
This is currently not done consistently, and a mechanism to ensure it across the whole system may be designed using
a global timestamping manager to be queries by all item saving processes (e.g., intercepting \mth{Util.CalendarGetInstance()} or \mth{Util.getGeneralizedTime()}).
 
\section{Incremental Synchronization}

Each agent Alice keeps for each polled peer Bob the latest arrival time of that peer, $arrival\_time_{Bob}$, up to each it has obtained all the data.
At each poll round, Alice will send to Bob the value it has for $arrival\_time_{Bob}$ (\mmb{lastSnapshot} in the request) and Bob will reply
back with bag of GIDs of sequential items (in the order given by arrival times), and starting immediately after the arrival time,
as well as the arrival time of the last of them to be used as the new $arrival\_time_{Bob}$ of Alice.

Alice also send in each poll a bag of GIDs it has obtained from Bob and which are for items that she does not have yet.
Therefore Bob gives priority in each reply to sending some of the objects requested by Alice in the poll, rather then 
sending new GIDs. First Bob ads to the reply message requested items until it reaches an overall size
of 3/4 of a datagram. 
New GIDs are sent only if after adding all requested data, the overall size of the obtained message is smaller than the maximum size of a datagram.

Bob has to send back the list of GIDs that he does not have, such that Alice avoids asking them again from him (this is not implemented yet!).

\section{Building SyncRequests}
The elements of a sync request, defined in class \pkg{hds}.\cls{ASNSyncRequest}, are:
\begin{itemize}
\item
\mmb{version}: the current version of the request structure is "2". It is not used since a best effort is done now at decoding.
\item
\mmb{lastSnapshot}: the arrival time of the last items etrieved from the destination. We want items with larger arrival times.
A null value signifies that we want a block of items with the smallest arrival times. This time is set to null
when we first query a peer or when we want to restart retrieving from beginnig (e.g., because we were announced by that peer
that they have changed the policy by which it disseminates its older data). Users can also request to reset this 
\mmb{lastSnapshot} via a GUI interface (r.g. peers and peer-instances widgets). The agent is storing the next \mmb{lastSnapshot}
for each instance in the \cls{peer\_instance} table, based on the answered received from that peer.
\item
\mmb{randomID} this stores a random string to make each request different to avoid replay attacks, as well as to
avoid replying twice to the same request that happens to arrvive simultaneously on two different paths.
\item
\mmb{tableNames}: is a set of names of tables that the peer supports (e.g., peers and news). In original versions of the streamming, peers
where shiping data as tables. This is currently scrapped since it is not sufficiently flexible to ship data of various versions, and this field can be deprecated and left empty.
\item
\mmb{orgFilter}: is a set of filters that tell which organization and which motions/constituents in that organzation are of interest to
this agent. The feature was implemented but was not tested in recent versions. It is currently sent empty to tell the peer that no filter
is installed.
\item
\mmb{address}: the \cls{D\_Peer} object of the peer sending the request, to be used for validating the request (and its signature) at the destination.
\item
\mmb{request}: the set of GIDHs that this user is interested in getting from the remote peer. It is an instance of \pkg{streaming}.\cls{SpecificRequest}, where GIDHs are groupped by organization, with one entry per organization in the array \mmb{rd} of 
\pkg{streaming}.\cls{RequestData}. The \cls{SpecificRequest} also contains lists of GIDs for global \mmb{news} and translations (\mmb{tran})
as well as a hashtable \mmb{peers} that maps peer GIDHs into their minimal creation dates requested.
\item
\mmb{plugin\_msg} contains a set of messages sent to the plugins of the remote peer and generated by the plugins of the sender, tagged with the plugin \mmb{GID}. These messages are typically saved by plugins in the database of the peer, and therefore they are retrived in this database when the request is built.
\item
\mmb{plugin\_info} is a set of descriptions of plugins registered with the sender agent, to let the receiver peer know about
the possibility to communicate with them.
\item
\mmb{pushChanges} has the structure of a \cls{ASNSyncPayload} response to a request and allows the sender of the request to push the data it
desires to the remote peer. Typically we place in it objects (motions,votes) recently created with the GUI editors of the sender agent.

This is calculated with \pkg{hds}.\cls{ClientSync}.\mth{getSyncReqPayload} which assembles the component \mmb{advertised}
of \mmb{pushChanges} (of type \cls{SpecificRequest}) by merging the data in \cls{ClientSync}.\mmb{\_payload\_fix}
describing items manually registered by the advertiser, with the data in  \cls{ClientSync}.\mmb{\_payload\_recent} describing
data recently created locally.

The registration of recent data is made with: \pkg{hds}.\cls{ClientSync}.\mth{addToPayloadAdvertisements()}.
\item
\mmb{signature}: is a signature of the whole request message, signed with the key of the agent mentioned in the field \mmb{address}.
\item
\mmb{dpi}: is the information of type \cls{D\_PeerInstance} about the instance of the sender peer describing the particular agent sending the message. It has its own signature.
\end{itemize}

The ASN1 description of the SyncRequest message is:
\begin{verbatim}
TableName := IMPLICIT [PRIVATE 0] UTF8String
NULLOCTETSTRING := CHOICE {
	OCTET STRING,
	NULL
}
ASNSyncRequest := IMPLICIT [APPLICATION 7] SEQUENCE {
	version UTF8String, -- currently 2
	lastSnapshot GeneralizedTime OPTIONAL,
	signature [APPLICATION 8] IMPLICIT NULLOCTETSTRING OPTIONAL,  
	tableNames [APPLICATION C0] IMPLICIT SEQUENCE OF [PRIVATE 0] IMPLICIT TableName OPTIONAL,
	orgFilter [APPLICATION C1] IMPLICIT SEQUENCE OF OrgFilter OPTIONAL,
	address [APPLICATION C2] IMPLICIT D_PeerAddress OPTIONAL,
	request [APPLICATION C3] IMPLICIT SpecificRequest OPTIONAL,
	plugin_msg [APPLICATION C4] IMPLICIT D_PluginData OPTIONAL,
	plugin_info [APPLICATION C6] IMPLICIT SEQUENCE OF ASNPluginInfo OPTIONAL,
	pushChanges ASNSyncPayload OPTIONAL,
	signature NULLOCTETSTRING, -- prior to version 2 it was [APPLICATION 5] 
	dpi [APPLICATION C7] Implicit D_PeerInstance OPTIONAL
}
\end{verbatim}

The request is commonly prepared in \pkg{hds}.\cls{ClientSync}.\mth{buildRequest()} and is handled by \pkg{hds}.\cls{UDPServerThread}.\mth{handleRequest()}.

\section{Replying SyncRequests}
A limit is preestablished on the number of objects we want to ship in the response of one request.
First a number of objects is sent to the destination based on the specific request of GIDHs received in the SyncRequest.

Function of the remaining space in the answer message, the remaining part of the answer is built in two passages. First the database is scanned separately for each type of object (peer, prganization ...) for data newer than the value of \mmb{lastSnapshot} in the request.
At each query of such data, a limit is set to the maximum number of retrieved objects, and tha maximum date is computed
as the date of the most recent object withing that limit. The output of this first passage is a date: the date until which data is retrieved.

In the second passage we gather GIDHs for all the data older than \mmb{lastSnapshot} and the at most as new as the date obtained in the 
first pass. GIDHs harvested in this passes (filtered to only contained broascasted objects that are not temporary and have GIDHs),
are mailed to the requesting peer.

\paragraph{TODO:} If a request comes for an object that this agent does not have ready, the peer has to be informed to avoid requesting that
object again. Otherwise we risk that future requests could be cluttered with GIDHs that I do not have and a practical DoS is acieved,
where I can no longer send anything to this peer. An attacker can create it by somehow convincinf a peer that I have these GIDHs.
It is therefore essential to warn the peer about the fact that they are not available at me. Recent changes were needed in the
data structure \pkg{streaming}.\cls{OrgPeerDatHashes} used to store items to request. However, these changes were not yet
fully implemented in the management of this data! See the MS thesis if Hussein Ihsan that has a discussion on the topic but unfortunately was not yet implemented.

\section{Integrating Data}

\chapter{AdHoc Synchronization}

\end{document}

